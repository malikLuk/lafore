/**
 *
 *                                                  Коды Хаффмана.
 * Далеко не все двоичные деревья являются деревьями двоичного поиска. Многие двоичные деревья используются для других
 * целей. Например, как уже было показано выше, для представления алгебраического выражения. Сейчас мы рассмотрим вариант
 * использования двоичных деревьев для сжатия данных.
 * Каждый символ обычного несжатого текстового файла представляется одним байтом(АСКИ) или двумя байтами(Юникод). В этих
 * свхемах каждый символ кодируется одинаковым количеством битов (рисунок huff_1). Существую различные способы сжатия
 * данных. Для текста, обычно, применяется способ, основанный на уменьшении количества битов в представлении самих символов.
 * Например, в английском языке чаще всего встречается буква E, поэтому для ее кодирования логично выбрать как можно меньшее
 * количество битов. С другой стороны, буква Z встречается редко, и большая длина ее кодировки не существенна.
 * Допустим, в представлении буквы Е используются всего два бита, например, 01. Закодировать двумя битами каждую букву
 * алфавита не получится, так как комбинаций всего четыре 00 01 10 11. Кроме того, нельзя использовать эти комбинации
 * для кодирования четырех наиболее часто встречающихся символов, так как нужно следить за тем, чтобы символы не начинались
 * с комбинации битов, присутствующих в начале более длинного битового кода другого исмвола. Например, если Е мы закодировали
 * как 01, а буква Х закодирована комбинацией 01011000, то декодирующий алгоритм не будет знать, является ли 01 кодом Е,
 * либо же это просто начало буквы Х. Отсюда правило - ни один код не должен быть префиксом другого кода. Также нужно
 * учесть, что в некоторых сообщениях, символ Е может и не быть самым частым. Например, если мы обрабатываем Java-код, то
 * символ ";" может встречаться чаще, чем Е. Чтобы справиться с этой проблемой, мы будем строить для каждого сообщения
 * новый адаптированный код. Допустим, надо перслать сообщение "SUSIE SAYS IT IS EASY". Буква S здесь встречаеься часто,
 * как и пробел. Создание кода начинается с построения частотной таблицы, в котрой указана частота вхождения каждого
 * символа (рисунок huff_2). Исмволы с наибольшим количеством вхождений должны кодироваться малым количеством битов. На
 * рисунке huff_3 представлена одна из возможных кодировок сообщения. Буква S кодируется 10, пробел - 00. Использовать
 * 01 или 11 нельзя, так как тогда они точно будут префиксами дургих символов. Переходим к 3-разрядным комбинациям.
 * У нас есть варианты 000 001 100 101 011 111 110 010, из которых надо убрать 000 001 100 101, так как их префиксы - это
 * коды символов S и пробел. Потом берем 4-разрядные комбинации и так далее.
 *
 * */

package ch_8;

public class HuffmanCodes {
}
