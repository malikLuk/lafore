/**
 *
 *                                                  Обход графа в ширину.
 * Как было показано ранее, алгоритм обхода в глубину позволяет как можно быстрее максимально удалиться от исходной вершины.
 * При обходе в ширину, напротив, алгоритм стремится держаться поближе к вершине. Он посещает все вершины, смежные с
 * исходной, и только после этого отходит дальше. Такой обход реализуется на базе очереди. На рисунке gr_11.png изображен
 * тот же граф, что и на gr_8.png, только стрелки указывают на порядок посещения вершин при обходе в ширину. Алгоритм
 * начинает с вершины A, посещает ее и делает текущей. Далее применяются следующие правила:
 *      Правило 1: Нужно посетить следующую вершину, не посещавшуюся ранее, смежную с текущей вершиной, пометить ее и
 *                 занести в очередь.
 *      Правило 2: Если выполнение правила 1 невозможно, извлечь вершину из очередии сделать ее текущей вершиной.
 *      Правило 3: Если выполнение правил 1 и 2 невозможно - обход закончен.
 * Рассмотрим на примере gr_11.png. Сначала посещаем вершины, смежные с A, таким образом, в очереди у нас окажутся вершины
 * B C D E. Все, вершины, смежные с A закончились. По правилу 2, достаем из очереди вершину. Это будет вершина B, очередь
 * теперь выглядит так C D E. Применяя правило 1, заносим вершину F в очередь, которая будет выглядеть так C D E F. Теперь
 * выполнение правила 1 невозможно, поэтому по правилу 2 извлекаем из очереди вершину C, в очереди остались D E F. Для
 * вершины C невозможно выполнение правила 1, поэтому по правилу 2, снова достаем вершину из очереди - вершина D. Очередь
 * на данный момент состоит из E F. Применяя правило 1, идем в вершину G и заносим ее в очередь (E F G). Так как у D не
 * осталось смежных вершин - достаем новую из очереди - E, осталось (F G) К ней неприменимо правило 1 и по правилу 2
 * достаем из очереди вершину F, теперь в очерди только G. Заносим смежную с F вершину H в очередь (G H) и по правилу 2
 * достаем из очереди вершину G, где останется только H. С вершиной G смежна I, которую заносим в очередь. Теперь очередь
 * состоит из H I. Но когда алгоритм извлекает эти вершины из очереди - он не находит для них смежных, поэтому выполнение
 * правил 1 и 2 становится невозможным, что является сутью правила 3. Обход закончен. Обход в ширину реализован в методе
 * bfs() класса DeepSearchRealization.
 * Обход в ширину обладает одним интересным свойством, он сначала находит все вершины, находящиеся на расстоянии одного
 * ребра от начальной вершины, затем все вершины, находящиеся на расстоянии двух ребер и т д. Это свойство может
 * пригодиться при поиске кратчайшего пути от начальной вершине к заданной. Во время обхода в ширину при обнаружении
 * заданной врешины мы точно будем знать, что построеннйы путь является кратчайшим путем к вершине. если бы более короткий
 * путь сущетсвовал, то алгоритм нашел бы его ранее.
 *
 * */

package ch13;

public class WideSearchRealization {
}
