/**
 *
 *                                                      Обход графа.
 * Одной из основных операций с графами является определение всех вершин, достижимых из заданной. Например, нужно узнать
 * до каких городов можно добраться пассажирским поездом из Перми(с возможными пересадками). До одних добраться можно,
 * другие города недоступны, так как там нет железной дороги, в третьих железная дорога не того типа и т д. Или, например,
 * мы проектируем микросхему. На ней есть контакты и дорожки - металлические полоски, по которым идет электричество до
 * контактов (gr_7.png). На графе контакты могут представляться вершинами, а дорожки ребрами.
 * Теперь нам нужен алгоритм, который начинается от заданной вершины и систематически перемещается по ребрам к другим
 * вершинам так, что после завершения его работы будут посещены все вершины, соединенные с исходной. Существует два
 * основных способа обхода графов: обход в глубину и обход в ширину. Оба спобоса обеспечивают перебор всех соединенных
 * вершин. Обход в глубину реализуется на базе стека, обход в ширину - на базе очереди. Это различие приводит к обходу
 * вершин графа в разном порядке.
 * Обход в глубину.
 * Алгоритм обхода в глубину хранит в стеке информацию о том, куда следует вернуться в случае тупика. Рассмотрим рисунок
 * gr_8.png. Начинаем с выбора отправной точки, в нашем случае, это вершина A. Затем алгоритм выполняет три операции:
 * посещает вершину, заносит ее в стек и помечает для предотвращения повторных посещений. Затем алгоритм переходит к
 * любой вершине, смежной с А, которая еще не посещалась ранее. Будем считать, что вершины выбираются в алфавитном
 * порядке; значит это будет вершина В. Алгоритм посещает В, помечает вершину и заносит в стек. Текущей вершиной является
 * В, значит алгоритм делает то же, что и прежде: он переходит к смежной еще не посещенной вершине, в нашем примере, это
 * вершина F. То есть
 *      Правило 1 - Посетить вершину, не посещавшуюся ранее, пометить ее и занести в стек.
 * Применение правила 1 приводит нас к вершине Н. Однако, на этот раз нужно сделать что-то другое, так как в графе не
 * осталось непосещенных вершин, смежных с Н. На помощь приходит
 *      Правило 2 - Если выполнение правила 1 невозможно, то нужно извлечь вершину из стека.
 * В соответствии с этим правилом вершина Н извлекается из стека, в результате чего алгоритм возвращается к вершине F.
 * Однако, у вершины F тоже нет непосещенных смежных вершин, следовательно, она тоже извлекается из стека. То же самое
 * происходит с вершиной В, и теперь в стеке остается только вершина А. У вершины А есть непосещенные смежные вершины,
 * поэтому алгоритм идет в вершину С. Но поскольку эта вершина тоже является тупиковой, по правилу 2, она извлекается из
 * стека, и алгоритм снова возвращается в вершину А. Далее алгоритм посещает вершины D, G, I, а затем снова извлекает их
 * при достижении тупика и возвращается в А. И в конце алгоритм посещает вершину Е, после чего снова идет в А. На этот
 * раз у вершины А не осталось непосещенных соседей и она тоже извлекается из стека. В стеке не остается элементов и тут
 * вступает в действие
 *      Правило 3 - Если выполнение правил 1 и 2 невозможно - обход закончен.
 * Содержимое стека в момент поиска описывает путь от исходной вершины до текущей.
 *
 * */

package ch13;

public class GraphDetour {
}
