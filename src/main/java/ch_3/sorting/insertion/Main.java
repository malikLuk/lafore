/**
 *
 *                                                Сортировка вставками.
 * Также работает за O(n^2), но работает, примерно, вдвое быстрее пузырьковой сортировки и немного быстрее сортировки
 * выбором. Также, сортировка вставками часто используется на завершающей стадии более сложных алгоритмов, например,
 * быстрой сортировки. По ходу работы этого алгоритма мы просто идем по массиву и ищем каждому элементу свое место.
 * Отсортированная подгруппа будет слева от текущего элемента(в ней и ищем места), а неотсортированная - справа.
 * В примере ниже это происходит так: во внешнем цикле for счетчик начинает с позиции 1 и двигается вправо по массиву.
 * Он принимает значение крайнего левого неотсортированного элемента. Мы записали это во временную переменную. Во
 * внутреннем цикле while счетчик начинает с позиции out двигаться влево и искать место для элемента внешнего цикла.
 * Он просто смещает элемент вправо если индекс больше 0 и следующий элемент больше нашего, записанного во временную
 * переменную. Если какое-то из условий не выполнено - мы записываем в освободившееся место значение нашей временной
 * переменной, а счетчик внешнего цикла for идет дальше.
 * Инвариантом здесь являетя то, что в конце каждого прохода, после вставки элемента из временной переменной, элементы
 * с индексами меньшими, чем out являются ЧАСТИЧНО отсортированными. Работает алгоритм также за O(n^2). Но у сортировки
 * вставками есть некоторый плюс - если данные ПОЧТИ отсортированы, то сортировка методом вставки выполняется за O(n),
 * так как условие цкила while чаще всего не будет выполняться (array[in - 1] >= temp), так как, напоминаю, данные
 * уже почти отсортированы. Другими словами, эта сортировка хорошо подходит для сортировки массивов уже отсортированных,
 * но с некоторыми отклонениями. А вот если данные отсортированы в обратном порядке, то алгоритм отработает все возможные
 * сравнения и перестановки.
 *
 * */

package ch_3.sorting.insertion;

public class Main {

  private long[] array;
  private int nElems;

  public Main(int max) {
    array = new long[max];
    this.nElems = 0;
  }

  public void insert(long value) {
    array[nElems] = value;
    nElems++;
  }

  public  void display() {
    for (int i = 0; i < nElems; i++) {
      System.out.print(array[i] + " ");
    }
    System.out.println();
  }

  public void insertionSort() {
    int in, out;
    for (out = 1; out < nElems; out++) {
      long temp = array[out];
      in = out;
      while (in > 0 && array[in - 1] >= temp) {
        array[in] = array[in-1];
        --in;
      }
      array[in] = temp;
      display();
    }
  }

  private void swap(int one, int two) {
    long temp = array[one];
    array[one] = array[two];
    array[two] = temp;
  }

  public static void main(String[] args) {
    int maxSize = 100;
    Main main = new Main(maxSize);
    main.insert(5);
    main.insert(7);
    main.insert(6);
    main.insert(1);
    main.insert(2);
    main.insert(0);
    main.insert(4);
    main.insert(3);
    main.insert(9);
    main.insert(8);

    main.display();
    main.insertionSort();
    System.out.println();
    main.display();
  }

}
