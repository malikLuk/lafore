/**
 *
 *                                                          Итераторы.
 * Допустим, тербуется перебрать элементы списка, выполняя некие операции с определенными элементами - скажем, увеличить
 * зарплату всех работников, которые получают минимальный оклад, а остальные не трогать. Или, скажем, из списка клиентов
 * интернет-магазина удалить записи всех покупателей, которые ничего не заказывали в последние полгода.
 * С массивами подобные операции выполняются просто, потому что для отслеживания текущей позиции можно воспользоваться
 * индексом. Однако, в связном списке элементы не имеют индексов. Каждый раз выполнять поиск элемента - невыгодно, так
 * как поиск всегда будет идти сначала и будет много лишнего перебора элементов списка. Намного эффективнее было бы
 * переходить от элемента к элементу, проверять, удовлетворяет ли элемент некоторому критерию, и, если проверка дает
 * положительный результат - выполнять с ним соответствующую операцию.
 * Ссылка на элемент списка.
 * Фактически, пользователю класса требуется ссылка, которая может указывать на произвольный элемент списка. По ссылке
 * пользователь может проверить или изменить элемент списка. Допустим, мы создали такую ссылку, где она должна размещаться?
 * Один из возможных вариантов - включить соответствующее поле непосредственно в список(какой-нибудь current или нечто
 * подобное). Пользователь обращается к элементу по ссылке current, а затем увеличивает current для перехода к следующему
 * элементу. Однако, у такого подхода имеется серьезный минус: пользователю может потребоваться несколько таких ссылок,
 * по аналогии с одновременным использованием нескольких индексов при работе с массивом. Невозможно заранее предсказать,
 * сколько таких ссылок потребуется, поэтому самым логичным решением будет предоставить пользователю возможность создать
 * столько ссылок, сколько ему необходимо. В рамках ООП - это будет внедрение каждой такой ссылке в объект класса. и это
 * не может быть класс списка, так как объект списка существует в одном экземпляре, поэтому обычно ссылка реализуется в
 * отдельном классе(ничего не понял).
 * Объекты, содержащие ссылки на элементы структур данных и используемые для перебора элементов этих структур, обычно
 * называют ИТЕРАТОРАМИ. Определение класса итератора выглядит примерно так:
 *
 * class ListIterator {
 *     private Link current;
 * }
 *
 * где поле current содержит ссылку, указывающую на элемент, на который в настоящее время смотрит итератор. Чтобы использовать
 * итератор, пользователь сначала создает список, а затем объект-итератор, ассоциированный с этим списком. Но лучше будет
 * поручить создание итератора списку, потому что список может передать итератору полезную информацию, например, ссылку
 * на first. По этой причине в класс списка включается метод getIterator(), который возврщает пользователю объект-итератор
 * для данного списка. Пример:
 *
 * psvm() {
 *     LinkList theList = new LinkList();               // создали список
 *     ListIterator iter1 = theList.getIterator();      // создали итератор
 *     Link aLink = iter1.getCurrent();                 // обратились к текущему элементу, на который указывает итератор
 *     iter1.next();                                    // переместили итератор к следующему элементу
 * }
 *
 * Итератор ВСЕГДА указывает на некоторый элемент списка. Он связан со списком, но не относится ни к классу списка, ни к
 * классу элемента списка.
 * Концептуальные методы итераторов:
 *
 * reset() - перемещение итератора в начало списка
 * next() - перемещение итератора к следующему элементу
 * getCurrent() - получение элемента, на который указывает итератор
 * atEnd() - true, если итератор находится в конце списка
 * insertAfter() - вставка нового элемента после итератора
 * insertBefore() - вставка нового элемента перед итератором
 * deleteCurrent() - удаление элемента, на который указывает итератор
 *
 * Тем не менее, бывает непросто решить, какие операции должны выполнятся иетратором, а какие самим списком.
 *
 * */


package ch_5;

public class Iterators {
}
