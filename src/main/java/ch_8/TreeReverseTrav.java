/**
 *
 *                                                      Обратный обход.
 * Кроме симметричного обхода, существуют еще два алгоритма - прямой и обратный. Польза от них не так очевидна, как от
 * симметричного обхода. Эти способы находят применение при разборе и анализе алгебраических выражений. Двоичное дерево
 * (но не дерево двоичного поиска!!!) может использоваться для представления алгебраических выражений с бинарными
 * операторами (+ - / *). В корневом узле хранится оператор, а в других узлах имя переменной(A, B или C) или другой
 * оператор. Каждое поддерево представляет действительное алгебраическое выражение, рисунок tree_10.Дерево с этого рисунка
 * представляет алгебраическое выражение A * (B + C). Это так называемая инфиксная запись, она получается при обходе
 * дерева в симметричном порядке (но круглые скобки придется вписать самостоятельно).Для прямого же обхода(метод preOrder())
 * используеются те же шаги, что и для симметричного, но выполняются они в другой последовательности:
 *   1. Посещение узла.
 *   2. Рекурсивный вызов самого себя для обхода левого поддерева.
 *   3. Рекурсивный вызов самого себя для обхода правого поддерева.
 * Для дерева с рисунка tree_10 будет сгенерировано выражение *A+BC - такая запись называется префиксной. Одно из ее
 * преимуществ - отсуствие необходимости в круглых скобках: от начала выражения каждый оператор применяется к следующим
 * двум операндам. В нашем случае, для оператора * это операнды A и +BC. Для оператора + это операнды B и C.
 * В обратном алгоритме обхода - метод выполняет те же шаги, опять же, в другой последовательности:
 *   1. Рекурсивный вызов самого себя для обхода левого поддерева.
 *   2. Рекурсивный вызов самого себя для обхода правого поддерева.
 *   3. Посещение узла.
 * Здесь в резульате получится такое выражение: ABC+*. Это постфиксная запись.
 *
 * */

package ch_8;

public class TreeReverseTrav {
}
