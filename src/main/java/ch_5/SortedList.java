/**
 *
 *                                                      Сортированные списки.
 * Это список, в котором данные упорядочены по значению ключа. Такой список модет использоваться почти во всех ситуациях,
 * в которых может использоваться сортированный массив. Преимущества перед массивом - быстрая вставка(не требующая
 * перемещения элементов) и возможность динамического расширения списка(тогда как массив ограничен фиксированным размером).
 * Сортированные списки могут использоваться для  реализации приоритетных очередей, хотя, чаще они реализуются на базе
 * кучи.
 * Реализация сортированного списка пердставлена ниже. Чтобы вставить элемент в сортированный список, сначала перебираются
 * элементы в поисках подходящей позиции для вставки, то есть позиции перед первым элементом, больше вставляемого. После
 * обнаружения такой позиции, элемент вставляется таким образом, что в поле next нового элемента заносится ссылка на
 * следующий элемент, а в поле next предыдущего элемента заносится ссылка на вставляемый. Однако, приходится учитывать
 * особые случаи: вставку в начало или конец списка.
 * Эффективность сортированных списков. Вставка и удаления из сортированных списков происходит в среднем за O(n), так как
 * позицию вставки и удаления приходится искать перебором списка. С другой стороны поиск и удаление наименьшего значения
 * выполняются за константное время, так как ссылка на это значение хранится всегда. Также сортированный список может
 * использоваться эффективного механизма сортировки. Например, у нас есть несортированный массив. Чтобы отсортировать его
 * мы просто в цикле читаем и элементы массива и вставляем их в сортированный список, в котором они будут автоматически
 * сортироваться, а уже из списка копируем элементы обратно в массив. Такой вид сортировки превосходит по эффективности
 * обычный метод вставки, потому что тут требуется меньше операций копирования, хотя она тоже выполняется за O(n^2).
 *
 * */


package ch_5;

public class SortedList {

    public static void main(String[] args) {
        SortedList sortedList = new SortedList();
        sortedList.insert(20);
        sortedList.insert(40);
        sortedList.insert(10);
        sortedList.insert(50);
        sortedList.insert(20);
        sortedList.insert(70);
        sortedList.insert(60);

        sortedList.displayList();
    }

    private LinkSorted first;

    public SortedList() {
        this.first = null;
    }

    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Вставка в порядке сортировки
     * */
    public void insert(long key) {
        LinkSorted newLink = new LinkSorted(key); // Создаем новый элемент
        LinkSorted previous = null;               // и идем от начала
        LinkSorted current = first;               // списка

        while (current != null && key > current.dData) { // ищем до тех пор
            previous = current;                          // пока не найдем
            current = current.next;                      // первый элемент, который
        }                                                // будет больше вставляемого
        if (previous == null) {                          // если список пустой, то понятно, ничего мы не найдем
            first = newLink;                             // и тогда просто добавляем первый элемент списку
        } else {                                         // если же мы нашли такой элемент
            previous.next = newLink;                     // то предыдущему ставим в next вставляемый элемент
        }                                                // а вставляемому в next ставим элемент, который нашли
        newLink.next = current;                          // то есть, первый, который больше вставляемого
    }

    /**
     * Удаление первого элемента
     */
    public LinkSorted remove() {
        LinkSorted temp = first;
        first = first.next;
        return temp;
    }

    public void displayList() {
        LinkSorted current = first;
        while (current != null) {
            current.displayLink();
            current = current.next;
        }
    }
}

class LinkSorted {

    public long dData;
    public LinkSorted next;

    public LinkSorted(long dData) {
        this.dData = dData;
    }

    public void displayLink() {
        System.out.println(dData);
    }
}
