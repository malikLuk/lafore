/**
 *
 *                                    Стеки и Очереди.
 * Стек. В стеке теоретически должен быть доступен только один элемент данных - тот, который был
 * вставлен в него последним. Удалив этот элемент, пользователь получает доступ к предпоследнему
 * элементу и т д. Стеки редко используются для хранения реальных данных, а скорее для упрощения
 * программирования. Например, стек можно использовать для проверки открытых/закрытых скобок. Многие
 * микропроцессоры имеют стековую архитектуру, то есть, операции со стеком встроены в микропроцессор.
 * Основные операции со стеком - вставка элемента в стек и извлечение элемента из него. Все эти операции
 * выполняются всегда с верхним элементом стека. Стек работает по принципу LIFO(Last-In-First-Out),
 * потому что последний занесенный в него элемент первым из него выйдет.
 * Концепция стека и структура данных, на которой он реализован - это разные понятия. Стек вполне может
 * быть построен на массиве, в котором доступен только последний элемент или на связном списке.
 *                                        Операции.
 * Push - вставляет в стек новый элемент. Вставляет на самый верх.
 * Pop - извлекает последний добавленный в стек элемент.
 * Peek - читает значение верхнего элемента стека, но не извлекает его. Согласно концепции, "подсмотреть"
 *        можно только последний элемент в стеке. Остальные - нет.
 *
 * Ниже описана простая реализация стека на основе массива. В классе BracketChecker реализована программа
 * проверки скобок. Стек работает за O(1).
 *
 * */



package ch_4.stack_and_queue;

public class Main {

  public static void main(String[] args) {
    StackX stack = new StackX(10);

    stack.push(20);
    stack.push(40);
    stack.push(60);
    stack.push(80);

    while (!stack.isEmpty()) {
      long val = stack.pop();
      System.out.println(val);
    }
  }

}

// Реализуем стек на основе массива
class StackX {

  private int maxSize;                          // максимальный размер стека
  private long[] stackArray;                    // массив, на котором основан стек
  private int top;                              // вершина стека - то есть, индекс последнего добавленного элемента

  public StackX(int s) {
    this.maxSize = s;                           // устанавливаем максимальный размер массива(и соотвественно стека)
    this.stackArray = new long[maxSize];        // создаем массив соотв размера
    top = -1;                                   // устанавливаем индекс верхнего (последнего) элемента -1, так как стек пустой
  }

  public void push(long j) {
    this.stackArray[++top] = j;                 // сначала увеличиваем индекс последнего элемента, а затем записываем туда значение
  }

  public long pop() {
    return this.stackArray[top--];              // при извлечении верхнего элемента из стека мы не удаляем его и базового массива
  }                                             // мы просто уменьшаем индекс последнего элемента на 1, а это значение потом перезапишется
                                                // при добавлении нового элемента. Здесь мы сначала возврщаем последний элемент,
                                                // а затем понижаем индекс.

  public long peek() {
    return this.stackArray[top];                // просто подсмотрели значение верхнего элемента
  }

  public boolean isEmpty() {
    return this.top == -1;
  }

  public boolean isFull() {
    return this.top == this.maxSize - 1;
  }


}
