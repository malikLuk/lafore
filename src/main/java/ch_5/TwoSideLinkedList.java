/**
 *
 *                                                  Двусторонние списки.
 * Двусторонний список похож на обычный связный список с одной дополнительной возможностью: в нем хранится не ссылка не
 * только на первый, но и на последний элемент. Наличие ссылки на последний элемент позволяет вставлять новые элементы
 * не только в начало, но и в конец связного списка. Конечно, вставить элемент в конец можно и в обычном односвязном
 * списке, но это потребует перебора всех элементов списка от начала и до конца, что не эффективно. Благодаря возможности
 * быстрого обращения к последнему элементу(вместе с первым) двусторонний связный список хорошо подходит для некоторых
 * ситуаций, в которых односторонний связный список не особо эффективен. Например, двусторонний связный список можно
 * использовать для реализации очереди. НЕ ПУТАТЬ ДВУСТОРОННИЙ СПИСОК С ДВУСВЯЗНЫМ СПИСКОМ.
 *                                              Эффективность связных списков.
 * Вставка и удаление в начало связного списка выполняются очень быстро, вся операция сводится к изменению одной-двух
 * ссылок, выполняемому за время O(1). Поиск, удаление и вставка рядом с конкретным элементом требуют перебора в среднем
 * половины элементов списка, для которого необходимо O(N) сравнений. У массива эти операции в среднем занимают тоже
 * O(N) времени, но  связный список все равно работает быстрее, потому что он не требует перемещения элементов при вставке
 * или удалении. Повышение эффективности может быть весьма значительным. Другое важно преимущество связных списков перед
 * массивами заключается в том, что связный список всегда использует ровно столько памяти, сколько необходимо и может
 * расширяться вплоть до всей доступной памяти. Фиксация размера массива при создании обычно приводит либо к неэффективному
 * памяти(если массив слишком мал) или исчерпанию всей доступной памяти(если массив слишком велик).
 *
 **/


package ch_5;

public class TwoSideLinkedList {
}
