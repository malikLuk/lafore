/**
 * Двоичные деревья.
 * Двоичное дерево сочетает в себе преимущества двух других структур данных: упорядоченного массива и связного списка.
 * Поиск выполняется также быстро как в упорядоченном массиве, а операции вставки и удаления - как в связном списке.
 * Дерево состоит из узлов, соединенных ребрами (рис tree_1). На самом деле, дерево является частным случаем более общей
 * структуры, называемой графом. В программах узлы часто представляют сущности: людей, детали машин, билеты и т д. Ребра,
 * или соединительные линии между узлами, представляют отношения между этими самыми узлами. Упрощенно говоря, программа
 * может легко и быстро перейти от узла к узлу, если между ними имеется соединительная линия. В общем случае - перемещение
 * происходит только в одном направлении: от корневого узла вниз. В Java-программах ребра - это ссылки. В C или C++ - это
 * указатели.
 * В Двоичном Дереве каждый узел имеет не более двух потомков. Формально, они называются Двоичными Деревьями Поиска(рис tree_4).
 * Ниже представлена терминология (рис tree_2).
 * Путь - это последовательность узлов, по которым надо пройти, чтобы соединить два нужных узла.
 * Корень - узел на самом верху дерева, он же - корневой узел. Дерево имеет только один корень. Чтобы совокупность узлов
 * и ребер могла называться деревом, от корня к любому другому узлу должен вести один (и тольк один!) путь. Структура
 * нарисунке tree_3 не является деревом, поскольку нарушает это правило.
 * Родитель - любой узел, кроме корневого имеет ровно одно ребро, уходящее вверх к другому узлу. Узел, расположенный выше
 * него называется родительским узлом(родителем) по отношению к данному узлу.
 * Потомок - любой узел может иметь одно или несколько ребер, соединяющих его с узлами более низкого уровня. Узлы,
 * находящиеся ниже заданного называются его потомками.
 * Лист - узел, не имеющий потомков.
 * Поддерево - любой узел может рассматриваться как корень поддерева, состоящего из его потомков, потомков его потомков
 * и т д.
 * Посещение - переход программы к узлу (обычно, с целью выполнения некоторой операции). Простое прохождение мимо посещением
 * не считается.
 * Обход дерева - посещение всех его узлов в некотором заданном порядке.
 * Уровень узла - количество поколений, отделяющих его от корня, если считать, что корень находится на нулевом уровне.
 * Ключи - одно из полей объекта называется ключевым. Ключ используется при поиске элемента или выполнении с ним других
 * операций. В данном случае - это нужное нам значение узла-объекта.
 * Грубый пример дерева (правда, не двочиного) - иерархическая файловая структура.
 * Несбалансированные деревья - это дерево, в котором большинство узлов состредоточено с одной стороны корня (tree_5).
 * Несбалансированными могут быть также и отдельные поддеревья. Узлы дерева, в самом распространенном случае, хранятся в
 * несмежных блоках памяти компьютера, а для их связывания в каждый узел включаются ссылки на его потомков. Дерево в
 * памяти также может быть представлено в виде массива - узлы, находящиеся в конкретных позициях, хранятся в соответствующих
 * позициях массива. В следующих примерах кода Java используется модель с соединением узлов посредством
 * ссылок.
 */

package ch_8;

/**
 * Для начала нам понадобится класс для представления объектов узлов.
 * Класс содержит данные, представляющие хранимые объекты (например,
 * описания работников для БД отдела кадров), а также ссылки на каждого
 * из двух потомков текущего узла. Некоторые программисты также включают
 * ссылку на родительский узел. Наличие таких ссылок упрощает одни операции,
 * но усложняет другие, поэтому мы их не используем. Сущетсвуют и другие
 * варианты проектирования класса Node. Вместо размещения данных непосредственно
 * в узле, можно воспользоваться ссылкой на объект, представляющий набор данных
 *
 * class Node {
 *     Person p1;
 *     Node leftChild;
 *     Node rightChild;
 * }
 * class Person {
 *     int iData;
 *     double fData;
 * }
 *
 * */

class Node {

    int iData;                  // Данные, используемые в качестве ключа
    double dData;               // Другие данные
    Node leftChild;             // Левый потомок
    Node rightChild;            // Правый потомоу

    public void displayNode() {

    }

}

/**
 * Также нам понадобится класс для представления всего дерева, Tree. Он содержит только одно поле, переменную Node,
 * в которой хранится корень дерева. Поля для других узлов не нужны, поскольку доступ к ним осуществляется через корневой
 * узел. Класс Tree содержит ряд методов для поиска, вставки и удаления узлов, различных видов обхода и вывода
 * содержимого дерева.
 * */
class Tree {

    private Node root;

    /**
     * Поиск всегда начинается с первого узла root, так как в дереве изначально напрямую доступен только он.
     * Поиск работает за логорифмическое время
     * */
    public Node find(int key) {
        Node current = root;
        if (current == null) {              // если ничего не нашли
            return null;                    // :'(
        }
        while (current.iData != key) {
            if (key < current.iData) {          // если ключ меньше значения в текущем узле
                current = current.leftChild;    // идем налево
            } else {
                current = current.rightChild;   // иначе направо
            }
        }
        return current;
    }

    /**
     * Здесь, в новой переменной parent(родитель current) хранится последний отличный от null узел дерева, посещенный при
     * переборе. Хранение его необходимо, так как для проверки того, что предыдущее значение current не имело подходящего
     * потомка, current присваивается null и если не сохранить узел в parent, то позиция в дереве потеряется.
     * */
    public void insert(int id, double dd) {
        Node newNode = new Node();          // Создание новго узла
        newNode.iData = id;
        newNode.dData = dd;

        if (root == null) {                 // Если нет корня - то вставляем в корень
            root = newNode;
        } else {
            Node current = root;            // Начать с корневого узла
            Node parent;
            while (true) {
                parent = current;
                if (id < current.iData) {
                    current = current.leftChild;
                    if (current == null) {              // Если дерево кончилось - присваиваем паренту новую ноду
                        parent.leftChild = newNode;
                        return;
                    }
                } else {
                    current = current.rightChild;
                    if (current == null) {              // Если дерево кончилось - присваиваем паренту новую ноду
                        parent.rightChild = newNode;
                        return;
                    }
                }
            }
        }
    }

    public boolean delete(int key) {
        // Ищем узел
        Node current = root;
        Node parent = root;
        boolean isLeftChild = true;

        while (current.iData != key) {
            parent = current;
            if (key < current.iData) {              // Двигаемся влево
                isLeftChild = true;
                current = current.leftChild;
            } else {
                isLeftChild = false;
                current = current.rightChild;
            }
            if (current == null) {              // Если не нашли
                return false;
            }
        }
        /**
         * Допустим, удаляемый узел найден. Сначала надо убедиться, что у него нет потомков.
         * Если условие выполнено - проверяем особый случай корневого узла. Если удаляемый узел
         * является корневым - то мы просто присваиваем ему null, что приводит к полной очистке
         * дерева. В противном случае - leftChild или rightChild присваивается null, чтобы
         * отсоединить узел от родителя.
         * */
        if (current.leftChild == null && current.rightChild == null) {
            if (current == root) {
                root = null;
            } else if (isLeftChild) {       // Отсоединяем узел от родителя
                parent.leftChild = null;
            } else {
                parent.rightChild = null;
            }
        }
        /**
         * Следующий код демонстрирует обработку ситуации с одним потомком. Возможны четыре варианта:
         * потомок удаляемого узла может быть левым или правым, и в каждом из этих двух случаев сам
         * узел может быть левым и правым потомком своего родителя. Также возможен особый случай, когда
         * удаляется корневой узел, не имеющий родителя - он просто заменяется соответствующим поддеревом.
         * В общем, если нет правого потомка - узел заменяется левым поддеревом. Если нет левого потомка -
         * узел заменяется правым поддеревом.
         * */
        if (current.rightChild == null) {  // Если у удаляемого узла нет правого потомка
            if (current == root) {
                root = current.leftChild;
            } else if (isLeftChild) {                   // А сам он является левым потомком
                parent.leftChild = current.leftChild;   // то левому потомку родителя узла присваивается левый потомок узла
            } else {                                    // А если он правый потомок
                parent.rightChild = current.leftChild;  // то правому потомку родителя узла присваивается левый потоком узла
            }
        } else if (current.leftChild == null) {        // Если нет правого потомка - то все наоборот
            if (current == root) {
                root = current.rightChild;
            } else if (isLeftChild) {
                parent.leftChild = current.rightChild;
            } else {
                parent.rightChild = current.rightChild;
            }
        }
        /**
         * Удаление узла с двумя потомками
         * */
        else {
            Node successor = getSuccessor(current);
            if (current == root) {
                root = successor;
            } else if(isLeftChild) {
                parent.leftChild = successor;
            } else {
                parent.rightChild = successor;
            }
            successor.leftChild = current.leftChild;
        }

        return true;
    }

    /**
     * Ниже приведен фрагмент кода метода getSuccessor(), который возвращает преемника узла, переданного
     * в аргументе delNode. Метод подразумевает, что у delNode есть правый потомок, но это условие заведомо
     * выполнено, так как вызов из метода delete(), означает, что у узла есть два потомка. Этот метод сначала
     * переходит к правому потомку удаляемого узла, а потом находит самого левого из его потомков. При выходе
     * из цикла while переменная successor содержит преемника delNode (удаляемого узла). При обнаружении
     * преемника также может возникнуть необходимость в обращении к его родителю, поэтому в цикле while
     * также отслеживается родитель текущего узла. Метод getSuccessor() также выполняет две дополнительные
     * операции, помимо поиска преемника. Однако, чтобы понять их смысл, необходимо взглянуть на общуу картину.
     * Как мы знаем, узел-преемник может занимать одну из двух возможных позиций относительно удаляемого узла:
     * он может быть его правым потомком, или входить в цепочку левых потомков его правого потомка.
     *
     * Первая ситуация. Преемник является правым потомком delNode. Здесь ситуация упрощается, так как мы
     * можем просто переместить все поддерево, корнем которого является преемник, на то место, где был
     * удаленный узел. Эта операция выполняется за два шага(рисунок tree_18):
     * 1. Отсоединить current(удаляемый узел) от поля rightChild(или leftChild) его родителя. Сохранить
     * в это поле ссылку на преемника.
     * 2. Отсоеденить левого потомка current от самого current и сохранить его в leftChild преемника.
     *
     * Вторая ситуация - преемник является крайним левым потомком правого потомка удаляемого узла. В этом
     * случае удаление происходит за четыре шага(рисунок tree_19):
     * 1. Сохранить ссылку на правого потомка преемника в поле leftChild родителя преемника.
     * 2. Сохранить ссылку на правого потомка удаляемого узла в поле rightChild преемника.
     * 3. Убрать current из поля rightChild(или leftChild) его родителя и сохранить в этом поле ссылку
     * на преемника.
     * 4. Убрать ссылку на левого потомка из current и сохранить ее в левом потомке(leftChild) преемника.
     * Шаги 1 и 2 выполняются в методе getSuccessor(), а 3 и 4 в методе delete()
     * */

    private Node getSuccessor(Node delNode) {
        Node successorParent = delNode;
        Node successor = delNode;
        Node current = delNode.rightChild;

        while (current != null) {
            successorParent = successor;
            successor = current;
            current = current.leftChild;
        }

        /**
         * это шаги 1 и 2
         * */
        if (successor != delNode.rightChild) {
            successorParent.leftChild = successor.rightChild;
            successor.rightChild = delNode.rightChild;
        }
        return successor;
    }

}

/**
 * наконец, с созданным деревом нужно выполнять операции. Следующий класс создает дерево и вставляет в него три узла, а
 * затем выполняет поск одного из них.
 * */
public class BinaryTreeApp {

    public static void main(String[] args) {
        Tree theTree = new Tree();
        theTree.insert(50, 1.5);
        theTree.insert(25, 1.7);
        theTree.insert(75, 1.9);

        Node found = theTree.find(25);

        if (found != null) {
            System.out.println("Found the node with key 25");
        } else {
            System.out.println("Not found");
        }
    }

}
